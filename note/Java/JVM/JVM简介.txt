
●.JVM的内存空间主要有以下：
    方法区，是各个线程共享的区域，存放类信息、常量、静态变量。
    Java堆，也是线程共享的区域，我们的类的实例就放在这个区域，可以想象你的一个系统会产生很多实例，
        因此java堆的空间也是最大的。如果java堆空间不足了，程序会抛出OutOfMemoryError异常。
    Java栈，是每个线程私有的区域，它的生命周期与线程相同，一个线程对应一个java栈，
        每执行一个方法就会往栈中压入一个元素，这个元素叫“栈帧”，而栈帧中包括了方法中的局部变量、用于存放中间状态值的操作栈。
        如果java栈空间不足了，程序会抛出StackOverflowError异常，递归容易诱发此类错误，递归如果深度很深，
        就会执行大量的方法，方法越多java栈的占用空间越大。
    本地方法栈，和java栈类似，只不过它是用来表示执行本地方法的，本地方法栈存放的方法调用本地方法接口，
        最终调用本地方法库，实现与操作系统、硬件交互的目的。

●.指令重排序: 编译器优化重排序 -> 指令级并行重排序 -> 内存系统重排序
    第一步属于编译器重排序，会按JMM的规范严格进行，换言之编译器重排序一般不会对程序的正确逻辑造成影响。
    第二、三步属于处理器重排序，会要求java编译器在生成指令时加入内存屏障。
        内存屏障把不能重排序的java指令保护起来，那么处理器在遇到内存屏障保护的指令时就不会对它进行重排序了。

●.jvm中自带的线程：
    Signal Dispatcher：Attach Listener 线程接收外部jvm命令，当命令接收成功后，会交给signal dispather线程去进行分发到各个不同的模块处理命令，并且返回处理结果。signal dispather线程也是在第一次接收外部jvm命令时，进行初始化工作。
    Attach Listener：Attach Listener 线程是负责接收到外部的命令，而对该命令进行执行的并且把结果返回给发送者。通常我们会用一些命令去要求jvm给我们一些反馈信息，如：java -version、jmap、jstack等等。如果该线程在jvm启动的时候没有初始化，那么，则会在用户第一次执行jvm命令时，得到启动。
    DestroyJavaVM：执行main()的线程在main执行完后调用JNI中的 jni_DestroyJavaVM() 方法唤起DestroyJavaVM 线程。JVM在服务器启动之后，就会唤起DestroyJavaVM线程，处于等待状态，等待其它线程（java线程和native线程）退出时通知它卸载JVM。线程退出时，都会判断自己当前是否是整个JVM中最后一个非daemon线程，如果是，则通知DestroyJavaVM 线程卸载JVM。
    Finalizer：这个线程也是在main线程之后创建的，其优先级为10，主要用于在垃圾收集前，调用对象的finalize()方法。
    Reference Handler：JVM在创建main线程后就创建Reference Handler线程，其优先级最高，为10，它主要用于处理引用对象本身（软引用、弱引用、虚引用）的垃圾回收问题。
