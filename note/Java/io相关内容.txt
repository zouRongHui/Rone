
●.字节、字符、字节流、字符流
    Bit 最小的二进制单位 ，是计算机的操作部分。取值 0 或者 1
    Byte（字节）是计算机操作数据的最小单位由 8 位 bit 组成 取值（-128-127）
    Char（字符）是用户的可读写的最小单位，在 Java 里面由 16 位 bit 组成 取值（0-65535）
    字节流：操作 byte 类型数据，主要操作类是 OutputStream、InputStream 的子类；不用缓冲区，直接对文件本身操作。
    字符流：操作字符类型数据，主要操作类是 Reader、Writer 的子类；使用缓冲区缓冲字符，不关闭流就不会输出任何内容。

●.同步、异步、阻塞、非阻塞
    同步、异步，是描述被调用方的。
        同步，B 在接到 A 的调用后，会立即执行要做的事。A 的本次调用可以得到结果。
        异步，B 在接到 A 的调用后，不保证会立即执行要做的事，但是保证会去做，B在做好了之后会通知 A。A 的本次调用得不到结果，但是 B 执行完之后会通知 A。
    阻塞，非阻塞，是描述调用方的。
        阻塞，A 在发出调用后，要一直等待，等着 B 返回结果。
        非阻塞，A 在发出调用后，不需要等待，可以去做自己的事情。

●.Linux 5 种 IO 模型
    阻塞式 IO 模型，最传统的一种 IO 模型，即在读写数据过程中会发生阻塞现象。
        当用户线程发出 IO 请求之后，内核会去查看数据是否就绪，如果没有就绪就会等待数据就绪，
        而用户线程就会处于阻塞状态，用户线程交出 CPU。当数据就绪之后，内核会将数据拷贝到用户线程，
        并返回结果给用户线程，用户线程才解除 block 状态。
    非阻塞 IO 模型，在非阻塞 IO 模型中，用户线程需要不断地询问内核数据是否就绪，也就说非阻塞 IO 不会交出 CPU，而会一直占用 CPU。
        当用户线程发起一个 read 操作后，并不需要等待，而是马上就得到了一个结果。如果结果是一个 error 时，
        它就知道数据还没有准备好，于是它可以再次发送 read 操作。一旦内核中的数据准备好了，
        并且又再次收到了用户线程的请求，那么它马上就将数据拷贝到了用户线程，然后返回。
    IO 复用模型，Java NIO 实际上就是多路复用 IO。
        在多路复用 IO 模型中，会有一个线程不断去轮询多个 socket 的状态，只有当socket 真正有读写事件时，
        才真正调用实际的 IO 读写操作。因为在多路复用 IO 模型中，只需要使用一个线程就可以管理多个 socket，
        系统不需要建立新的进程或者线程，也不必维护这些线程和进程，并且只有在真正有 socket 读写事件进行时，
        才会使用 IO 资源，所以它大大减少了资源占用。
    信号驱动 IO 模型。
        在信号驱动 IO 模型中，当用户线程发起一个 IO 请求操作，会给对应的 socket 注册一个信号函数，
        然后用户线程会继续执行，当内核数据就绪时会发送一个信号给用户线程，用户线程接收到信号之后，
        便在信号函数中调用 IO 读写操作来进行实际的 IO 请求操作。
    异步 IO 模型，是比较理想的 IO 模型。
        当用户线程发起 read 操作之后，立刻就可以开始去做其它的事。而另一方面，从内核的角度，
        当它受到一个asynchronous read 之后，它会立刻返回，说明 read 请求已经成功发起了，
        因此不会对用户线程产生任何 block。然后，内核会等待数据准备完成，然后将数据拷贝到用户线程，
        当这一切都完成之后，内核会给用户线程发送一个信号，告诉它 read 操作完成了。
        也就说用户线程完全不需要实际的整个 IO 操作是如何进行的，只需要先发起一个请求，
        当接收内核返回的成功信号时表示 IO 操作已经完成，可以直接去使用数据了。

●.