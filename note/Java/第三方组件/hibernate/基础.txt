
●. hibernate.cfg.xml 配置文件
    rone-core/src/main/resources/hibernate/hibernate.cfg.xml

●. hibernate中数据的四种状态
    临时态：新建的对象，不在session缓存中，也不在数据表中
    持久化态：在session缓存中，也在数据表中
    游离态：不在session缓存中，但在数据表中
    删除态：被删除的对象，不存在

●. session主要方法
    void session.flush();根据session缓存中的数据更新数据表中的记录(可能是insert、delete或update)
    void session.refresh(Object);根据数据表中的记录去更新session缓存中的数据
    void session.clear();清空session缓存
    Serializable session.save(Object);将Object加入session缓存进入持久化状态
    Object session.get(Class, Serializable);根据指定的ID从数据库获取一个持久化对象，没有时返回null，立即检索
    void/Object session.load(Class, Serializable);根据指定的ID从数据库获取一个持久化对象，没有时抛出异常，延时检索
    void session.update(Object);将一个游离状态的对象转变成持久化对象
    void session.saveOrUpdate(Object);根据对象的OID去判断该对象是游离状态(save操作)还是临时状态(update操作)
    Object session.merge(Object);首先判断对象是游离态还是临时态，1)临时态:持久化该对象；2)游离态：判断session缓存中是否有同OID的持久化对象
        ①有的话将持久化对象属性更新为该参数属性，返回引用，②否则判断数据表中是否有该OID的记录，没有的话同1)，有的话先从数据表加载该对象然后同①
    void session.delete(Object);根据Object(游离态or持久化态)的OID去数据表中删除记录，若OID在数据表中不存在会抛出异常
    void session.evict(Object);将一个持久化对象从session缓存中删除，变成游离态

●. 自关联，@ManyToOne、@OneToMany
    rone-core/src/main/java/org/rone/core/util/hibernate/entity/People.java
    ●).fetch 当一个实体类配置了 @ManyToOne、@OneToMany 等关联实体时，其默认的fetch获取方式(FetchType.EAGER)为主类被加载时关联的属性类数据也会立即被加载。
        而当我们把设置 fetch=FetchType.LAZY 时，主类数据加载后属性类数据不会立即被加载，这样可以提高主类的加载性能。
            当我们需要主类的性能又想在部分地方查询主类时属性类的数据也会立即加载时可以使用 left join fetch 语句来实现。
        eg.
            String hql = "from Item i left join fetch i.order left join fetch i.product where i.order.id=:paras0 order by i.sort";

●. HQL hibernate的数据库操作语法与具体的数据库无关，hibernate会自动解析成具体数据库的SQL语句
    demo：
        //1. 创建Query对象
        String hql = "from POJO n where n.id > ?";
        Query query = session.createQuery(hql);
        //2. 绑定参数
        query.setInteger(0, 0);
        //3. 执行查询
        List<POJO> listNews = query.list();
    ●).HQL语句支持占位符设置参数，也支持命名参数
        String hql = "from News n where n.id > :id";
        query.setInteger("id", 0);
    ●).分页检索
        setFirstResult 设置从哪开始检索
        setMaxResults 设置最多一次检索的对象数
        ********************************************
        //分页检索
        String hql = "from News ";
        Query query = session.createQuery(hql);
        int pageSize = 4;
        int pages = 2;
        //设置该页的首项
        query.setFirstResult((pages - 1) * pageSize);
        //设置每页的数据量
        query.setMaxResults(pageSize);
        List<News> listNews = query.list();
        ********************************************
    ●).投影检索，查询结果仅包含部分属性
        第一种，以Object接收检索数据
        ********************************************
        String hql = "select n.id, n.title from News n";
        Query query = session.createQuery(hql);
        List<Object[]> list = query.list();
        ********************************************
        第二种，以POJO接收检索数据
        ********************************************
        //需要在POJO中创建只有所检索的属性的构造器器
        String hql = "select new News(n.id, n.title) from News n";
        Query query = session.createQuery(hql);
        List<News> list = query.list();
        ********************************************


●. Hibernate乐观锁，能自动检测多个事务对同一条数据进行的操作，并根据先胜原则，提交第一个事务，其他的事务提交时则抛出org.hibernate.StaleObjectStateException异常。
    原理就是通过一个字段来判断当前数据表中的数据是否是当前事务读数时的数据，如果不是则报错，如果是则事务提交成功
    实现语法：数据表中新增一个字段(类型只能是 long,integer,short,timestamp,calendar，数字或timestamp)用来做版本控制，在实体类中用 @Version 标注该属性用于版本控制。
    当两个事务同一时间获取到数据A，事务1提交成功后，事务2提交时，由于事务2中版本控制字段的值与数据库中的值不一致(因为事务1提交成功后版本控制字段值会更新)，会抛出org.hibernate.StaleObjectStateException异常。
