

### ddl、sql
```mysql
-- ddl
-- 建库
create database 数据库名;
-- 建表
CREATE TABLE `表名` (
  字段 bigint(20) NOT NULL AUTO_INCREMENT,
  字段2 varchar(36) NOT NULL COMMENT '字段说明',
  字段3 varchar(200) DEFAULT NULL COMMENT '字段说明',
  字段4 datetime NOT NULL COMMENT '字段说明',
  字段5 int(11) DEFAULT '0' COMMENT '0;未删除,1:已删除',
  PRIMARY KEY (`字段`),
  KEY `自定义索引名` (`字段`),
  KEY `建议加上前缀：inx_` (`字段`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT='表说明';
-- 删库
drop database 数据库名;
-- 删表
drop table 表名;
-- 修改表结构
-- 新增字段
ALTER TABLE 表名 ADD 字段名 VARCHAR(20) DEFAULT '0' NOT NULL COMMENT 'just have a try';
-- 删除字段
ALTER TABLE 表名 DROP 字段名;
-- 增加索引
alter table 表名 add index 索引名(字段,字段2);
create index 索引名 on 表名(字段,字段2);
-- 查看表的建表语句
show create table 表名;
-- 查看表结构
desc 表名;

-- sql
-- 清空表数据，操作前备份哦
truncate table 表名
```

************************************************************************************************************************
### 函数
* 条件判断
    * IFNULL(expr1,expr2)：如果expr1不为NULL,返回expr1,否则返回expr2
    * NULLIF(expr1,expr2): 如果expr1==expr2则返回NULL, 否则返回expr1
    * IF(expr1,expr2,expr3)：如果expr1!=0 or !=NULL,则返回expr2的值，否则返回expr3的值
    * CASE expr1 WHEN value1 THEN result1 [WHEN value2 THEN result2 ...] ELSE resultN end:
      如果expr1的值为value1则返回result，如果值为value2则返回result2，... 如果都不相同则返回resultN
      tips:该方法仅能进行==匹配
    * CASE WHEN expr1<0 THEN result1 [WHEN expr1>=0 and expr1<10 THEN result2 ...] ELSE resultN END;
      如果expr1小于0返回value1，大于等于0小于10返回result2，否则返回resultN
    * COALESCE(value,...): 返回第一个不是NULL的值，如果都是NULL则返回NULL

* 字符串
    * length(str): 返回字符串的字节长度，如utf8中，一个汉字3字节，数字和字母算一个字节
    * REPEAT(str,count)：返回str重复count次得到的新字符串
    * concat(s1, s1, ...): 返回连接参数产生的字符串
    * concat_ws(x, s1, s2, ...): 使用连接符x连接其他参数产生的字符串
    * LOCATE(substr,str): 返回字符串中特定子串的位置
    * LOCATE(substr,str,pos), 返回在pos位置之后首次出现substr相对于str的位置
    * FIELD(str,str1,str2,str3,...): 返回str在后面的str列表中第一次出现的位置，
      若找不到str或者str为NULL, 则返回0。常用来实现自定义排序

* 数值
    * CEIL(X)/CEILING(X): 向上取整, SELECT CEILING(2.01);//3, SELECT CEIL(-2.01);//-2
    * RAND():返回一个[0, 1)

* explain 模拟优化器执行SQL查询语句，可以查看到sql执行时的一些情况

* substr(string,start,length) 截取数据库某个字段中的一部分。与java不同，这里是从索引从1起始
    ```mysql
    select substr('123456',3,2); -- 34
    select substr('123456',-3,2); -- 45
    select substr('123456',0,2); -- 12
    select substr('123456',1,2); -- 12
    ```

************************************************************************************************************************
### solutions
#### 表之间的数据转移
  `INSERT INTO 目标表 (字段1, 字段2, ...) SELECT 字段1, 字段2, ... FROM 来源表 ;`

#### 排序时遇到空值，默认情况下MySQL会认为NULL值比其他类型的数据小，在处理null值的数据排序时，可以借助isnull()函数来实现预期效果
  `order by isnull(i.order.sendTime), i.order.sendTime` 效果为 i.order.sendTime忽略null值从小到大排序，null值数据在最后

#### 中文排序
  `ORDER BY CONVERT(属性名 USING gbk)`

#### 自定义排序
  `order by field(type,2,3,1)` 按照 2 3 1 来排序

#### 多表间的更新
  `update user t1, user t2 set t1.user_explain = t2.user_explain where t1.user_no = '1' and t2.user_no='2';`

************************************************************************************************************************
### 事务
```mysql
start transaction;
-- 写类型的语句
commit;
```
*  在事务的并发中可能会发生下列问题，
  * 脏读：事务A读取了事务B提交的数据，然后事务B回滚了，此时事务A就是读取了脏数据。
  * 幻读：事务A将某个属性都更新为了true，事务B新增了一个该属性为false的记录，此时事务A就发觉还有个记录的属性为false，感觉发生了幻觉一样。
  * 不可重复读：在事务A多次读取某一数据时，事务B更新了某一数据，导致事务A前后读取的数据不一致。

* 为了解决事务的并发的问题引入了事务隔离级别，默认为可重复读

| 事务隔离级别                 | 脏读 | 不可重复读 | 幻读 |
|------------------------|----|-------|----|
| 读未提交（read-uncommitted） | 是  | 是     | 是  |
| 不可重复读（read-committed）  | 否  | 是     | 是  |
| 可重复读（repeatable-read）  | 否  | 否     | 是  |
| 串行化（serializable）      | 否  | 否     | 否  |

************************************************************************************************************************
### 开发规约
* 创建table时要避免使用了数据库的关键字和保留字

* 表的定义
  * 字段长度，要根据实际的业务数据来评估数据长度并做好扩展预估。
    常见的问题是字段长度都配置为varchar(255)，在不知道业务将来存多少长度的情况下，先设成255，在开发阶段可能比较方便，但存在性能隐患。
    比如索引评估，在一个255列长的字段上建索引，实际索引评估会考虑列长，如果默认255长度，会导致索引使用时评估不准确。
    再比如字段，如果字段有2个255或3个255要做复合索引时，虽然真实的值可能每个字段长度只存了10或20，在默认参数配置下会发现索引由于太长建不出来，对线上维护与后续业务开发都有影响。
  * 主键，建议定义为 int 类型。
    主键在业务中建议强制必须建立。可以保证主从架构下的数据一致性以及避免复制时性能问题。
    主键要如果采用数值型建议使用无符号类型，一般来说在一个表里ID肯定是自增的，不存在负值，如果定义一个有符号Int，会导致Int可用的值少一半。
    因为Int最大的值在有符号情况下是21亿，如果定义成无符号最大可以到42亿。说明数据快速增长时，有符号类型导致ID或某个自增长满的问题。
  * 禁止Null值。
    比如在排序场景下，两个行按某个允许null的列值做排序，如果不存储有意义的值，默认为null值的情况下，会导致一个随机的顺序，实际上就是业务上的乱序。
    又比如无主键表情况下，会导致复制数据不一致的问题，所以要禁止空值。

* 索引
  * 单列索引要充分评估，比如有20个列，每个列上都有1个单列的情况，会造成对写入的影响很大，同时单列索引的建议一定要评估可选择性。
  * 定期Review索引有效性，索引是不是在业务中真正使用在MySQL里相对不好定位，失效索引在业务快速发展频繁变更的场景下会很常见，随着新业务新添加很多新索引，
    这时要看新的索引是不是已经覆盖之前的旧索引，此时旧索引实际上是没有用的。维护无效索引要多一份IO成本，删除除重复索引保留有效的即可。
  * 不要走极端，包括两点：复合索引所有列与所有列都建单列索引。
    比如一张表有七八个列，只在单列有索引，因为索引有回表不回表的区别，所以直接建立一个包含所有列复合索引，这个方法不可取，虽然提升了查询的效率，但等于又另外维护了一张所有字段都要排序的表。
    所有列都建单列索引，实际上跟是复合索引所有列是一样的。主要消耗会出现索引维护上。

* Explain 判断语句是否已最优。
  其中Type与Extra的主要类型与含义如下：
  * Type
    * 1）ALL：Full Table Scan 全表扫描；
    * 2）index: Full Index Scan，索引扫描；
    * 3）range:范围扫描；
    * 4）ref: 表示连接匹配条件；
    * 5）eq_ref: 类似ref，区别就在使用的索引是唯一索引；
    * 6）const: 常量查询，比如pk等值；
    * 7）system是Const类型的特例；当查询的表只有一行的情况下，使用system。
    * 从性能角度来看，从上往下性能越来越高，根据《开发手册》，此处最低要求是到Range范围扫描。
  * Extra
    * 1）Using filesort 排序；
    * 2）Using index 使用索引可以返回请求列；
    * 3）Using index condition 通过索引初步过滤；回表再过滤其它条件；
    * 4）Using temporary 临时表；
    * 5）Using where 单独出现时；一般代表表上出现全表扫描过滤；
    * 6）Using index & Using where 使用索引返回数据；同时通过索引过滤。
    * Extra反映了执行计划的真实执行情况。

* 禁止与建议
  * 禁止项
    * select *，返回无用数据，过多IO消耗，以及Schema 变更问题；
    * Insert语句指定具体字段名称，不要写成insert into t1 values(…)，道理同上；
    * 禁止不带WHERE，导致全表扫描以及误操作；
    * Where条件里等号左右字段类型必须一致，否则可能会产生隐式转换，无法利用索引；
    * 索引列不要使用函数或表达式，否则无法利用索引。如where length(name)=‘Admin’或where user_id+2=5；
    * Replace into，会导致主备不一致；
    * 业务语句中带有DDL操作，特别是Truncate。
  * 建议项
    * 减小三表以上Join；
    * 用Union all 替代Union；
    * 使用Join 替代子查询；
    * 不要使用 like ‘%abc%’，可以使用 like ‘abc%’；
    * Order by 、distinct 、group by 都可以利用索引有序性；
    * 减少使用存储过程，通过业务逻辑实现；
    * 减小where in() 条件数据量；
    * 减少过于复杂的查询和拼串写法。

* 对于数据库使用要做到最简，将运算、判断等应用逻辑放到sql外实现。避免数据库成为性能瓶颈。

* 分页的优化
  * 分页的传统写法：select * from sbtest1 order by id limit M,N 需要扫描大量无效数据后，再返回请求数据，成本很高。
  * 根据业务场景，有以下三种解决方法：
    * `select * from sbtest1 where id > #max_id# order by id limit n;`
      适用顺序翻页的场景，每次记录上一页#max_id#带入下一次查询中。
    * `select * from sbtest1 as a inner join (select id from sbtest1 order by id limit m, n) as b on a.id = b.id order by a.id;`
      适用只按照id进行分页，无Where条件。
    * `select * from sbtest1 as a inner join (select id from sbtest1 where col=xxxx order by id limit m, n) as b on a.id = b.id order by a.id;`
      适用于带Where条件，同时按照ID顺序分页。此时，需要在Where条件上创建二级索引。

* 隐式转换问题。发生在比较值类型不一致的场景下，除去一些规定情况，所有的比较最终都是转换为浮点数进行。
    ```mysql
    -- 此类问题在编写sql语句时很难发现，上线可能会导致严重的性能问题。
    Create table testtb(id varchar(10) primary key);
    Select * from testtb where id=1;
    ```

************************************************************************************************************************
### 优化
* 优化的手段
  * SQL及索引
  * 库表结构
  * 系统配置
  * 硬件优化

* 关注的指标
  * CPU使用率，是SQL查询关键资源指标，CPU的消耗一般来自于数据扫描与显式计算。
  * IOPS，是衡量磁盘压力的指标，它指的是每秒IO请求的次数，对数据库来说，IOPS是物理读写的关键资源指标。
  * QPS/TPS，指MySQL数据库的吞吐量，也能在一定程度上反映应用系统的业务压力。
  * 会话数/活跃会话数，一般在应用配置问题，没有合理使用到连接池，或者SQL执行效率较差的时候出现这类的指标异常问题，这些情况会导致数据库的Server端产生大量的会话，甚至会积压大量的活跃会话。
  * Innodb逻辑读/物理读，这是主要用于反映数据库实例整体查询效率的引擎指标。
  * 临时表，通常来说，产生临时表往往意味着SQL执行效率的下降。

* 优化流程
  * 构建完备的监控体系。为了获取性能数据，分析及诊断问题，需要建立一套相对完备的监控体系。对于这块，首先需要有细致合理的告警，其次有多维度图形化指标，只有做到这两点，才可以暴露整个系统的性能缺陷，从而掌握大规模资源。
  * 当出现问题，或者当我们发现资源指标趋势跟预想不一致的时候，需要分析定位问题，这个过程就是性能诊断。一般关注5点，第一，发生异常时间区间；第二，系统日志以及数据库的错误日志；第三，Slow Log日志；第四，通过合理手段对SQL执行统计；第五，Session会话分析。诊断分析之后，定位到某些会话或者某些SQL语句，可以看到异常行为。
  * 分析业务逻辑，包括3点，第一，读写需求，请求量是不是正常；第二，事务精简，事务是不是有设计上的缺陷；第三，资源调用关系，比如SQL执行本身不慢，但是因为资源调用关系，出现锁等待的问题。以上问题分析清楚之后，接下来才是要对真正有性能问题的SQL进行优化。
  * SQL优化，关于这块主要包括4点，第一，Explain查看SQL执行计划；第二，SQL改写；第三，索引调整；第四，参数调整。

* 优化原则，减少数据访问量与减少计算操作。
  * 减少访问量：数据存取是数据库系统最核心功能，所以IO是数据库系统中最容易出现性能瓶颈，减少SQL访问IO量是SQL优化的第一步；数据块的逻辑读也是产生CPU开销的因素之一。
  * 减少访问量的方法：创建合适的索引、减少不必访问的列、使用索引覆盖、语句改写。
  * 减少计算操作：计算操作进行优化也是SQL优化的重要方向。SQL中排序、分组、多表连接操作等计算操作，都是CPU消耗的大户。
  * 减少SQL计算操作的方法：排序列加入索引、适当的列冗余、SQL拆分、计算功能拆分。

* 优化方法
  * 创建索引减少扫描量；
  * 调整索引减少计算量；
  * 索引覆盖（减少不必访问的列，避免回表查询）；
  * SQL改写；
  * 干预执行计划；

************************************************************************************************************************
### other
* 查询缓存，MySQL的查询缓存其实就是key-value形式，key为sql语句、数据库、版本协议等等的hash值，value为结果，
  且该缓存的维护机制为一旦数据表发生变动该数据表的所有的缓存立即清空，
  还有因为key值为hash值，所有语句必须一模一样才能击中缓存
