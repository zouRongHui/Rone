
●.表的定义
    字段长度，要根据实际的业务数据来评估数据长度并做好扩展预估。
        常见的问题是字段长度都配置为varchar(255)，在不知道业务将来存多少长度的情况下，先设成255，在开发阶段可能比较方便，但存在性能隐患。
        比如索引评估，在一个255列长的字段上建索引，实际索引评估会考虑列长，如果默认255长度，会导致索引使用时评估不准确。
        再比如字段，如果字段有2个255或3个255要做复合索引时，虽然真实的值可能每个字段长度只存了10或20，在默认参数配置下会发现索引由于太长建不出来，对线上维护与后续业务开发都有影响。
    主键，建议定义为 int 类型。
        主键在业务中建议强制必须建立。可以保证主从架构下的数据一致性以及避免复制时性能问题。
        主键要如果采用数值型建议使用无符号类型，一般来说在一个表里ID肯定是自增的，不存在负值，如果定义一个有符号Int，会导致Int可用的值少一半。
        因为Int最大的值在有符号情况下是21亿，如果定义成无符号最大可以到42亿。说明数据快速增长时，有符号类型导致ID或某个自增长满的问题。
    禁止Null值
        Null & Null =?。比如在排序场景下，两个行按某个允许null的列值做排序，如果不存储有意义的值，默认为null值的情况下，会导致一个随机的顺序，实际上就是业务上的乱序。
        又比如无主键表情况下，会导致复制数据不一致的问题，所以要禁止空值。
●.索引
    单列索引要充分评估，比如有20个列，每个列上都有1个单列的情况，会造成对写入的影响很大，同时单列索引的建议一定要评估可选择性。
    定期Review索引有效性，索引是不是在业务中真正使用在MySQL里相对不好定位，失效索引在业务快速发展频繁变更的场景下会很常见，随着新业务新添加很多新索引，
        这时要看新的索引是不是已经覆盖之前的旧索引，此时旧索引实际上是没有用的。维护无效索引要多一份IO成本，删除除重复索引保留有效的即可。
    不要走极端，包括两点：复合索引所有列与所有列都建单列索引。
        比如一张表有七八个列，只在单列有索引，因为索引有回表不回表的区别，所以直接建立一个包含所有列复合索引，
        这个方法不可取，虽然提升了查询的效率，但等于又另外维护了一张所有字段都要排序的表。
        所有列都建单列索引，实际上跟是复合索引所有列是一样的。主要消耗会出现索引维护上。
●.执行顺序
    1 .FROM,（-including JOIN ）
    2. WHERE
    3. GROUP BY
    4. HAVING
    5. WINDOW functions
    6. SELECT
    7. DISTINCT
    8. UNION
    9. ORDER BY
    10. LIMIT and OFFSET
    从执行顺序上看，在SELECT之前的所有子语都是在做数据筛选，SELECT以后开始执行运算，用户应注意数据流的流向。
    order by limit一般是在最后运行，如果在一开始运行，有时候会造成返回数据量过大，进而导致执行时间过长。
●.Explain 判断语句是否已最优。
    其中Type与Extra的主要类型与含义如下：
    Type
        1）ALL：Full Table Scan 全表扫描；
        2）index: Full Index Scan，索引扫描；
        3）range:范围扫描；
        4）ref: 表示连接匹配条件；
        5）eq_ref: 类似ref，区别就在使用的索引是唯一索引；
        6）const: 常量查询，比如pk等值；
        7）system是Const类型的特例；当查询的表只有一行的情况下，使用system。
        从性能角度来看，从上往下性能越来越高，根据《开发手册》，此处最低要求是到Range范围扫描。
    Extra
        1）Using filesort 排序；
        2）Using index 使用索引可以返回请求列；
        3）Using index condition 通过索引初步过滤；回表再过滤其它条件；
        4）Using temporary 临时表；
        5）Using where 单独出现时；一般代表表上出现全表扫描过滤；
        6）Using index & Using where 使用索引返回数据；同时通过索引过滤。
        Extra反映了执行计划的真实执行情况。
●.禁止与建议
    1.禁止项
        1）select *，返回无用数据，过多IO消耗，以及Schema 变更问题；
        2）Insert语句指定具体字段名称，不要写成insert into t1 values(…)，道理同上；
        3）禁止不带WHERE，导致全表扫描以及误操作；
        4）Where条件里等号左右字段类型必须一致，否则可能会产生隐式转换，无法利用索引；
        5）索引列不要使用函数或表达式，否则无法利用索引。如where length(name)=‘Admin’或where user_id+2=5；
        6）Replace into，会导致主备不一致；
        7）业务语句中带有DDL操作，特别是Truncate。
    2.建议项
        1）减小三表以上Join；
        2）用Union all 替代Union；
        3）使用Join 替代子查询；
        4）不要使用 like ‘%abc%’，可以使用 like ‘abc%’；
        5）Order by /distinct /group by 都可以利用索引有序性；
        6）减少使用event/存储过程，通过业务逻辑实现；
        7）减小where in() 条件数据量；
        8）减少过于复杂的查询和拼串写法。
●.对于数据库使用要做到最简，将运算、判断等应用逻辑放到sql外实现。避免数据库成为性能瓶颈。
●.分页的优化
    分页的传统写法：select * from sbtest1 order by id limit M,N 需要扫描大量无效数据后，再返回请求数据，成本很高。
    根据业务需求，有以下三种解决方法：
        1）select * from sbtest1 where id > #max_id# order by id limit n;
            适用顺序翻页的场景，每次记录上一页#max_id#带入下一次查询中。
        2）select * from sbtest1 as a inner join (select id from sbtest1 order by id limit m, n) as b on a.id = b.id order by a.id;
            适用只按照id进行分页，无Where条件。
        3）select * from sbtest1 as a inner join (select id from sbtest1where col=xxxx order by id limit m, n) as b on a.id = b.id order by a.id;
            适用于带Where条件，同时按照ID顺序分页。此时，需要在Where条件上创建二级索引。
●.隐式转换问题
    隐式转换问题发生在比较值类型不一致的场景下，除去一些规定情况，所有的比较最终都是转换为浮点数进行。
    Create table testtb(id varchar(10) primary key);
    Select * from testtb where id=1;
    此类问题在编写sql语句时很难发现，上线可能会导致严重的性能问题。
●.常见问题
    ●. Where 后面的列顺序是不是要符合最左原则？
        Where a=1 and b=2 等价于 Where b=2 and a=1
        最左原则指的是索引顺序，不是谓词顺序，以上两个条件都匹配( a,b) 复合索引。
    ●. Join 的顺序是否指定左边为驱动表？
        Inner Join场景下，在执行计划中按统计信息的预估自动选中驱动表，Left Join ,Right Join 时左右写的顺序才有显式意义。
    ●.业务上有随机返回的需求，能否用order by rand()
        一般不建议，如果结果集非常小，勉强可用，但结果集大时由于随机数排序，会产生Sort操作甚至溢出到磁盘，有很大性能损耗，此类需求可以考虑伪随机算法。
    ●.Delete数据之后，为什么磁盘空间占用反而大了？
        Delete数据并不能清理数据文件空间，反而会导致Undo,Binlog文件的增长，使用Optimize收缩。
    ●.Binlog是否一定要Row格式？
        在主从场景下，Binlog使用Row格式是为了保证主从数据一致性。
        单机场景下，Binlog做为增长数据备份使用，同时也包括一些语句级数据恢复的功能。
    ●.死锁、阻塞的区别
        通常说的阻塞，主要是由于锁获取不到，产生的请求被阻塞，一般需要手动解锁(Kill或等待)。
        死锁不等于阻塞，虽然死锁中阻塞是必现的，但是会自动回滚事务解锁，不用手动处理，但需要业务判断语句逻辑。
        以上两种情况都是由于业务侧逻辑出现，并非内核原因。
    ●.做DDL时是否会锁表
        所有的DDL都需要锁表，只是操作顺序和操作获取时间的问题。




