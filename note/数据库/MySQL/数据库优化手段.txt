
●.优化的手段
    SQL及索引
    库表结构
    系统配置
    硬件优化

●.关注的指标
    第一：CPU使用率，是SQL查询关键资源指标，CPU的消耗一般来自于数据扫描与显式计算。
    第二：IOPS，是衡量磁盘压力的指标，它指的是每秒IO请求的次数，对数据库来说，IOPS是物理读写的关键资源指标。
    第三：QPS/TPS，指MySQL数据库的吞吐量，也能在一定程度上反映应用系统的业务压力。
    第四：会话数/活跃会话数，一般在应用配置问题，没有合理使用到连接池，或者SQL执行效率较差的时候出现这类的指标异常问题，这些情况会导致数据库的Server端产生大量的会话，甚至会积压大量的活跃会话。
    第五：Innodb逻辑读/物理读，这是主要用于反映数据库实例整体查询效率的引擎指标。
    第六：临时表，通常来说，产生临时表往往意味着SQL执行效率的下降。

●.优化流程
    第一步，构建完备的监控体系。为了获取性能数据，分析及诊断问题，需要建立一套相对完备的监控体系。对于这块，首先需要有细致合理的告警，其次有多维度图形化指标，只有做到这两点，才可以暴露整个系统的性能缺陷，从而掌握大规模资源。
    第二步，当出现问题，或者当我们发现资源指标趋势跟预想不一致的时候，需要分析定位问题，这个过程就是性能诊断。一般关注5点，第一，发生异常时间区间；第二，系统日志以及数据库的错误日志；第三，Slow Log日志；第四，通过合理手段对SQL执行统计；第五，Session会话分析。诊断分析之后，定位到某些会话或者某些SQL语句，可以看到异常行为。
    第三步，分析业务逻辑，包括3点，第一，读写需求，请求量是不是正常；第二，事务精简，事务是不是有设计上的缺陷；第三，资源调用关系，比如SQL执行本身不慢，但是因为资源调用关系，出现锁等待的问题。以上问题分析清楚之后，接下来才是要对真正有性能问题的SQL进行优化。
    第四步，SQL优化，关于这块主要包括4点，第一，Explain查看SQL执行计划；第二，SQL改写；第三，索引调整；第四，参数调整。

●.SQL优化原则与方法
    优化原则，减少数据访问量与减少计算操作。
        减少访问量：数据存取是数据库系统最核心功能，所以IO是数据库系统中最容易出现性能瓶颈，减少SQL访问IO量是SQL优化的第一步；数据块的逻辑读也是产生CPU开销的因素之一。
            减少访问量的方法：创建合适的索引、减少不必访问的列、使用索引覆盖、语句改写。
        减少计算操作：计算操作进行优化也是SQL优化的重要方向。SQL中排序、分组、多表连接操作等计算操作，都是CPU消耗的大户。
            减少SQL计算操作的方法：排序列加入索引、适当的列冗余、SQL拆分、计算功能拆分。
    优化方法
         1）创建索引减少扫描量；
         2）调整索引减少计算量；
         3）索引覆盖（减少不必访问的列，避免回表查询）；
         4）SQL改写；
         5）干预执行计划；

●.常规的SQL优化策略
    ●.Order by语句优化，
        Order by查询的两种情况：
            1）Using index，是针对查询优化器的两种行为来去区分的。Using index就是说MySQL它可以直接通过索引去返回有序的记录，而不需要去经过额外的排序的操作；
            2）Using file sort，需要去做额外的排序，在某些特殊的情况下，可能还会出现临时表排序的情况。
        优化目标：尽量通过索引来避免额外的排序，减少CPU资源的消耗。
        主要优化策略：
            1）Where条件和Order by使用相同的索引；
            2）Order by的顺序和索引顺序相同；
            3）Order by 的字段同为升序或降序。
            注：当Where条件中的过滤字段为覆盖索引的前缀列，而Order by字段是第二个索引列时，只有Where条件是Const匹配时，才可以通过索引消除排序，而between…and或>?、<?这种Range匹配都无法避免Filesort操作。
        当无法避免File sort操作时，优化思路就是让File sort的操作更快。
        ·排序算法
            1）两次扫描算法。两次访问数据，第一步获取排序字段的行指针信息，在内存中排序，第二步根据行指针获取记录。
            2）一次扫描算法。一次性取出满足条件的所有记录，在排序区中排序后输出结果集。是采用空间换时间的方式。
            注：需要排序的字段总长度越小，越趋向于第二种扫描算法，MySQL通过max_length_for_sort_data参数的值来进行参考选择。
        ·优化策略
            1）适当调大max_length_for_sort_data这个参数的值，让优化器更倾向于选择第二种扫描算法；
            2）只使用必要的字段，不要使用Select *的写法；
            3）适当加大sort_buffer_size这个参数的值，避免磁盘排序的出现（线程参数，不要设置过大）。
    ●.sub query，对于子查询，一般的优化策略是做等价改写，在MySQL查询优化器中也叫反嵌套。在MySQL里，查询优化器本身也可以做一些简单查询的反嵌套操作，但在绝大部分情况下还是需要去做一些人为的干预。
        sub query优化总结：
            1）子查询会用到临时表，需尽量避免；
            2）可以使用效率更高的Join查询来替代。
        ·优化策略
            等价改写、反嵌套。
        如下SQL：
            select * from customer where customer_id not in (select customer_id from payment)
        改写形式：
            select * from customer a left join payment b on a.customer_id=b.customer_id where b.customer_id is null
        如上图所示，SQL语句用Not In的这样的方式，在子查询里执行Select语句。对于这个SQL语句，直接把Not In改写成Left Join，从而提升它的执行效率。在MySQL里，一般情况下Join的效率比子查询要高。
    ●.Limit，分页查询，就是将过多的结果在有限的界面上分多页来显示。其实质是每次查询只返回有限行，翻页一次执行一次。
        优化目标
            1）消除排序；
            2）避免扫描到大量不需要的记录。
        SQL场景（film_id为主键）：
            select film_id,description from film order by title limit 10000,20
        此时MySQL排序出前10020条记录后仅仅需要返回第10001到10020条记录，前 10000条记录造成额外的代价消耗。
        对于分页查询的优化的策略，主要有两个
        1）覆盖索引，记录直接从索引中获取，效率最高。仅适合查询字段较少的情况。
            Alter table film add index idx_limit_test(title,description);
        2）SQL改写，思路是从索引中取出20条满足条件记录的主键值，然后回表获取记录。优化的前提是Title字段有索引。
            select a.film_id,a.description from film a inner join (select film_id from film order by title limit 1000,20) b on a.film_id=b.film_id;
    ●.Or/And 条件逻辑优化
        And条件可以在前一个条件过滤基础上过滤；
        Or条件被处理为UNION，相当于两个单独条件的查询；
        复合索引对于Or条件相当于一个单列索引。
        处理策略
            1）And子句多个条件中拥有一个过滤性较高的索引即可;
            2）Or条件前后字段均要创建索引;
            3）为最常用的And组合条件创建复合索引。
    ●.join优化
        1)关联字段索引：每层内部循环仅获取需要关心的数据。
        2)小表驱动，以数据量更少的表作为主表，减少join循环次数。
    ●.Insert优化
        1)减少交互次数，使用批量插入语句。
        2)文本装载方式，通过LOAD DATA INFILE句式从文本装载数据，通常比Insert语句快20倍。





