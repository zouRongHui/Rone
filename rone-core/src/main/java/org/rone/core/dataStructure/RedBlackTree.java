package org.rone.core.dataStructure;

/**
 * 红黑树
 * 红黑树的操作模拟工具 https://www.cs.usfca.edu/~galles/visualization/RedBlack.html
 * ● 红黑树(Red-Black Tree)是一个自平衡(不是绝对的平衡)的二叉查找树(Binary Search Tree)
 *     树上的每个节点都遵循下面的规则:
 *         1.结点是红色或黑色。
 *         2.根结点是黑色。
 *         3.每个叶子结点都是黑色的空结点（NIL结点）。
 *         4.每个红色结点的两个子结点都是黑色。(从每个叶子到根的所有路径上不能有两个连续的红色结点)
 *         5.从任一结点到其每个叶子的路径都包含相同数目的黑色结点。
 *     红黑树有两大操作:
 *         recolor (重新标记黑色或红色)
 *         rotation (旋转，这是树达到平衡的关键)
 *     在对红黑树操作时，会优先进行 recolor 无效时才会 rotation
 * ● 红黑树 插入
 *     术语：X(当前节点),P(父节点),U(叔伯节点),G(祖父节点)
 *     1. 新插入的 X 标志为红色。
 *     2. 如果 X 为根节点则标记成黑色。
 *     3. 如果 P 为红色，同时 X 也不是根节点；
 *         C1：当 U 为红色，【变色操作】
 *             将 P 和 U 标记为黑色
 *             将 G 标记为红色
 *             让 X 的颜色和 G 的颜色一致，将 G 赋值给 X 后重复2、3步骤
 *         C2：当 U 为黑色/不存在(Null节点)，【旋转操作】
 *             左左：P 是 G 的左孩子、X 是 P 的左孩子
 *                 将 P 提升一个级别，G 变更为 P 的右孩子，P 改为黑色，G 改为红色，P 的右孩子自动调整以符合二叉查找树
 *             左右：P是G的左孩子、X是P的右孩子
 *                 先将 X 与 P 互换( X 的左孩子自动调整以符合二叉查找树），然后在按照左左的情况处理(此时 X 为 P)
 *             右右：P是G的右孩子、X是P的右孩子
 *                 将 P 提升一个级别，G 变更为 P 的左孩子，P 改为黑色，G 改为红色，P 的左孩子自动调整以符合二叉查找树
 *             右左：P是G的右孩子、X是P的左孩子
 *                 先将 X 与 P 互换( X 的右孩子自动调整以符合二叉查找树），然后在按照右右的情况处理(此时 X 为 P)
 * ● 红黑树 删除
 *     二叉查找树的删除流程
 *         情况1：要删除的节点无子节点，直接删除即可
 *         情况2：要删除的节点只有一个节点，删除当前节点，用唯一的那个子节点补上即可
 *         情况3：要删除的节点有两个节点，需要选择与待删除结点最接近的节点值来取代它。
 *             找到左节点中最右的叶节点、右节点中最左的叶节点，选择一个与当前节点最近的节点值替换，然后删除那个替换的节点。
 *             若删除的节点有子节点，可参考 情况2 处理。
 *     红黑树的删除参考 https://mp.weixin.qq.com/s/X3zYwQXxq93P_XUzFmKluQ
 * @author rone
 */
public class RedBlackTree {
    // todo:
}
